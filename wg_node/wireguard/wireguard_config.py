import pathlib

from aiofile import async_open
from loguru import logger

from wg_node.config import config
from wg_node.database import Peer
from wg_node.wireguard.key_storage import KeyStorage
from wg_node.util import execute
from wg_node.wireguard.key import generate_keypair

# These constants are defined here and not in any other place (e.g. not in ENV variables)
# mostly because they are not meant to be changed and also to prevent confusion

# remember to update mount point in docker-compose.yml when updating key storage path
_KEY_STORAGE_PATH = "/etc/wg-node/server-keys.json"
_WG_CONFIG_PATH = "/etc/wireguard/wg0.conf"

_WG_BASE_ADDRESS = "10.0.0.x"

_SERVER_INTERFACE_ADDRESS = _WG_BASE_ADDRESS.replace("x", str(1))
_SERVER_INTERFACE_LISTEN_PORT = 51820

_PEER_PERSISTENT_KEEPALIVE = 0
_PEER_DNS = "1.1.1.1, 8.8.8.8"


def generate_peer_address(taken_addresses: list[str]) -> str | None:
    """Generates free IP address for a new peer"""

    # adding server address to list of taken addresses 'cause it cannot be used for new peer
    taken_addresses.append(_SERVER_INTERFACE_ADDRESS)

    for x in range(2, 255):
        address = _WG_BASE_ADDRESS.replace("x", str(x))
        if address not in taken_addresses:
            return address
    return None


class WireguardConfig:
    """
    WireguardConfig is interface to interact with Wireguard configuration files
    It has methods to generate its content and to write it to the file.
    """

    _path: pathlib.PosixPath

    _private_key: str
    _public_key: str

    def __init__(self, path: str, *, private_key: str, public_key: str):
        self._path = pathlib.PosixPath(path)
        self._private_key = private_key
        self._public_key = public_key

    async def write(self, content: str):
        """Asynchronously writes content to the config file"""

        async with async_open(self._path, "w") as file:
            await file.write(content)

    def generate_config_content(self, peers: list[Peer]) -> str:
        """Generates and returns Wireguard config according to peers and server settings."""

        content = f"""# generated by wg-node
 
[Interface]
PrivateKey = {self._private_key}
Address = {_SERVER_INTERFACE_ADDRESS}/24
ListenPort = {_SERVER_INTERFACE_LISTEN_PORT}

PreUp =
PostUp =  iptables -t nat -A POSTROUTING -s {_WG_BASE_ADDRESS.replace("x", "0")}/24 -o eth0 -j MASQUERADE; iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT; iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT;
PreDown =
PostDown =
"""
        for i, peer in enumerate(peers):
            if peer.enabled:
                content += f"""
# uuid={peer.uuid}
[Peer]
PublicKey = {peer.public_key}
PresharedKey = {peer.preshared_key}
AllowedIPs = {peer.address}/32
"""
        return content

    def generate_peer_config(self, peer: Peer) -> str:
        """Generates and returns config for an individual peer."""

        content = f"""[Interface]
PrivateKey = {peer.private_key}
Address = {peer.address}/24
DNS = {_PEER_DNS}

[Peer]
PublicKey = {self._public_key}
PresharedKey = {peer.preshared_key}
Endpoint = {config.Wireguard.PUBLIC_HOSTNAME}:{config.Wireguard.PUBLIC_PORT}
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = {_PEER_PERSISTENT_KEEPALIVE}
"""
        return content

    @staticmethod
    def sync():
        """Synchronizes Wireguard config"""
        execute("wg syncconf wg0 <(wg-quick strip wg0)")


# initialize server key storage
_key_storage = KeyStorage(path=_KEY_STORAGE_PATH)
if not _key_storage.exists():
    private_key, public_key = generate_keypair()
    _key_storage.store_keys(private_key=private_key, public_key=public_key)
    logger.info("generated and stored server public keys")

# initialize wireguard config
_private_key, _public_key = _key_storage.read_keys()
WIREGUARD_CONFIG = WireguardConfig(
    path=_WG_CONFIG_PATH, private_key=_private_key, public_key=_public_key
)
