import pathlib

from wg_node.config import config
from wg_node.database import Peer

# import subprocess


# from aiofile import async_open


# These constants are defined here and not in any other place (e.g. not in ENV variables)
# mostly because they are not meant to be changed and also to prevent confusion
_SERVER_INTERFACE_ADDRESS = "10.0.0.1/16"
_SERVER_INTERFACE_LISTEN_PORT = 51820

_PEER_INTERFACE_ADDRESS_PATTERN = "10.0.x.y/16"
_PEER_PERSISTENT_KEEPALIVE = 0
_PEER_DNS = "1.1.1.1, 8.8.8.8"


def generate_peer_address(taken_addresses: list[str]) -> str | None:
    """Generates free IP address for a new peer"""

    # adding server address to list of taken addresses 'cause it cannot be used for new peer
    taken_addresses.append(_SERVER_INTERFACE_ADDRESS)
    for x in range(1, 255):
        for y in range(1, 255):
            address = _PEER_INTERFACE_ADDRESS_PATTERN.replace("x", str(x)).replace("y", str(y))
            if address not in taken_addresses:
                return address
    return None


class WireguardConfig:
    """
    WireguardConfig class manages Wireguard configuration file (usually /etc/wireguard/wg0.conf).
    It contains methods for generating it, writing to it and synchronizing Wireguard daemon with it.
    """

    _path: pathlib.PosixPath

    _private_key: str
    _public_key: str

    # content is None by default, gets its value only when _generate(...) method called
    _content: str | None = None

    def __init__(self, path: str, *, private_key: str, public_key: str):
        self._path = pathlib.PosixPath(path)
        self._private_key = private_key
        self._public_key = public_key

    # async def _async_write(self):
    #     async with async_open(self._path, "w") as file:
    #         await file.write(self._content)

    def _write(self):
        """Save wireguard config to its path"""
        with open(self._path, "w", encoding="utf-8") as file:
            file.write(self._content)

    def _generate(self, peers: list[Peer]):
        """
        Generates wireguard config content (ONLY updates `self.content` variable)
        according to peers and server settings.
        """
        self._content = f"""# generated by wireguard-node
           
        [Interface]
        PrivateKey = {self._private_key}
        Address = {_SERVER_INTERFACE_ADDRESS}
        ListenPort = {_SERVER_INTERFACE_LISTEN_PORT}
        # PreUp = {1}
        # PostUp = {2}
        # PreDown = {3}
        # PostDown = {4}

        """

        for peer in peers:
            self._content += f"""
            # uuid={peer.uuid}
            [Peer]
            PublicKey = {peer.public_key}
            PresharedKey = {peer.preshared_key}
            AllowedIPs = 0.0.0.0/0, ::/0;
            
            """

    def get_peer_config(self, peer: Peer) -> str:
        """Generates and returns config for an individual peer"""
        content = f"""
        [Interface]
        PrivateKey = {peer.private_key}
        Address = {peer.address}
        DNS = {_PEER_DNS} 
        
        [Peer]
        PublicKey = {self._public_key}
        PresharedKey = {peer.preshared_key}
        Endpoint = {config.Wireguard.HOSTNAME}:${config.Wireguard.PORT}`;
        AllowedIPs = 0.0.0.0/0, ::/0
        PersistentKeepalive = {_PEER_PERSISTENT_KEEPALIVE}
        """

        return content

    def _sync(self):
        """Synchronizes currently running Wireguard daemon with current config file"""
        # subprocess.run()

    def update(self, peers: list[Peer]):
        """
        Fully updates Wireguard configuration, applies it immediately.
        Generates new config content, writes it to the configuration file and
        kindly asks Wireguard daemon to pay attention to it :)
        """
        self._generate(peers)
        self._write()
        self._sync()
